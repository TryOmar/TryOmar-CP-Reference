\documentclass[11pt,a4paper]{article}

% Essential packages first
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}  % Better font handling

% Basic formatting packages
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{array}
\usepackage{booktabs}

% Math and graphics
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}

% Colors and listings
\usepackage{xcolor}
\usepackage{listings}

% Table of contents
\usepackage{tocloft}

% Hyperref should be last
\usepackage{hyperref}
\hypersetup{
    pdftitle={Competitive Programming Reference},
    pdfauthor={TryOmar},
    pdfsubject={Competitive Programming Algorithms and Data Structures},
    pdfkeywords={competitive programming, algorithms, data structures},
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=red
}

% Page geometry
\geometry{
    paper=a4paper,
    left=2cm,
    right=2cm,
    top=2.5cm,
    bottom=2.5cm,
    headheight=15pt,
    includehead,
    includefoot
}

% Code listing setup
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    captionpos=t,
    backgroundcolor=\color{gray!10},
    aboveskip=2em,
    belowskip=2em
}

% Remove listing prefix from captions
\renewcommand{\lstlistingname}{}
\renewcommand{\lstlistlistingname}{}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textsc{Competitive Programming Reference}}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Title formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Table of contents setup
\renewcommand{\cftsecfont}{\bfseries}
\renewcommand{\cftsubsecfont}{\normalsize}

\begin{document}

% Title page
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge\bfseries Competitive Programming Reference\par}
    \vspace{1cm}
    
    {\Large TryOmar's Algorithm Collection\par}
    \vspace{2cm}
    
    {\large A comprehensive collection of algorithms, data structures, and templates\par}
    \vspace{1cm}
    
    {\large \today\par}
    
    \vfill
    
    {\large \textsc{Generated from Markdown Reference}\par}
\end{titlepage}

% Table of contents
\tableofcontents
\newpage

% Introduction
\section{Introduction}
This document contains a comprehensive collection of algorithms, data structures, and templates for competitive programming. Each section includes implementation details, time complexity analysis, and usage examples.

\subsection{How to Use This Reference}
\begin{itemize}
    \item \textbf{Code Templates}: Ready-to-use implementations
    \item \textbf{Complexity Analysis}: Time and space complexity for each algorithm
    \item \textbf{Usage Examples}: Practical examples and edge cases
    \item \textbf{Notes}: Important implementation details and optimizations
\end{itemize}

\vspace{1cm}

\newpage

\section{Data Structures}

\subsection{STL Basics}
This section covers the essential C++ Standard Template Library (STL) data structures commonly used in competitive programming.

\subsubsection{Important STL Concepts}

\begin{itemize}
\item \textbf{Containers}: Data structures that hold objects (vector, set, map, etc.)
\item \textbf{Iterators}: Objects that point to elements in containers
\item \textbf{Algorithms}: Functions that operate on containers (sort, find, etc.)
\item \textbf{Function Objects}: Objects that can be called like functions
\item \textbf{Allocators}: Manage memory allocation for containers
\end{itemize}

\subsubsection{Common STL Operations}
\begin{itemize}
\item \textbf{Insertion}: \texttt{insert()}, \texttt{push\_back()}, \texttt{emplace()}
\item \textbf{Deletion}: \texttt{erase()}, \texttt{pop\_back()}, \texttt{clear()}
\item \textbf{Access}: \texttt{at()}, \texttt{operator[]}, \texttt{front()}, \texttt{back()}
\item \textbf{Size}: \texttt{size()}, \texttt{empty()}, \texttt{capacity()}
\item \textbf{Iteration}: Range-based for loops, iterators, \texttt{begin()}, \texttt{end()}
\end{itemize}

\subsubsection{Performance Considerations}
\begin{itemize}
\item \textbf{Vector}: O(1) amortized insertion at end, O(n) insertion in middle
\item \textbf{Set/Map}: O(log n) for insert, delete, search (Red-Black tree)
\item \textbf{Unordered Set/Map}: O(1) average case, O(n) worst case (hash table)
\item \textbf{Stack/Queue}: O(1) for push/pop operations
\item \textbf{Priority Queue}: O(log n) for push/pop operations
\end{itemize}

\subsubsection{Memory Management}
\begin{itemize}
\item \textbf{Vector}: Automatically grows, use \texttt{reserve()} to pre-allocate
\item \textbf{Set/Map}: Memory allocated per node, efficient for sparse data
\item \textbf{Unordered}: Memory allocated in buckets, good for dense data
\item \textbf{Stack/Queue}: Memory allocated as needed, efficient for LIFO/FIFO
\end{itemize}

\newpage

\subsubsection{Vectors and Arrays}

\begin{lstlisting}[caption={Basic Vector Operations}]
// Vector initialization
vector<int> v;                // Empty vector
vector<int> v(5);            // Size 5, initialized with 0s
vector<int> v(5, 2);         // Size 5, initialized with 2s
vector<int> v = {1, 2, 3};   // Direct initialization

// Basic operations
v.push_back(4);              // Add element to end
v.pop_back();                // Remove last element
v.size();                    // Get current size
v.empty();                   // Check if empty
v.front();                   // First element
v.back();                    // Last element
v.clear();                   // Remove all elements

// Access and iteration
for(int i = 0; i < v.size(); i++) {
    cout << v[i] << " ";     // Using index
}
for(int x : v) {             // Range-based for loop
    cout << x << " ";
}
\end{lstlisting}

\begin{lstlisting}[caption={2D Vector Operations}]
// 2D vector initialization
vector<vector<int>> grid(n, vector<int>(m));    // n x m grid
vector<vector<int>> grid = {                    // Direct init
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Access elements
grid[i][j] = value;          // Set value
int value = grid[i][j];      // Get value

// Common operations
for(int i = 0; i < grid.size(); i++) {
    for(int j = 0; j < grid[i].size(); j++) {
        cout << grid[i][j] << " ";
    }
    cout << "\n";
}
\end{lstlisting}

\subsubsection{Sets and Maps}

\begin{lstlisting}[caption={Set and Unordered Set}]
// Set (ordered)
set<int> s;                  // Ordered unique elements
s.insert(5);                 // O(log n) insertion
s.erase(5);                 // O(log n) deletion
auto it = s.find(5);        // O(log n) search
auto it = s.lower_bound(5); // First element >= 5
auto it = s.upper_bound(5); // First element > 5

// Unordered Set (hash table)
unordered_set<int> us;      // Unordered unique elements
us.insert(5);               // O(1) average case
us.erase(5);               // O(1) average case
auto it = us.find(5);      // O(1) average case
\end{lstlisting}

\begin{lstlisting}[caption={Map and Unordered Map}]
// Map (ordered)
map<string, int> m;         // Key-value pairs
m["apple"] = 5;             // O(log n) insertion
m.erase("apple");          // O(log n) deletion
auto it = m.find("apple"); // O(log n) search

// Unordered Map (hash table)
unordered_map<string, int> um; // Hash table
um["apple"] = 5;              // O(1) average case
um.erase("apple");           // O(1) average case
auto it = um.find("apple");  // O(1) average case
\end{lstlisting}


\begin{lstlisting}[caption={Multiset and Multimap Operations}]
// Multiset (allows duplicates)
multiset<int> ms;
ms.insert(5);               // Can insert multiple 5s
ms.erase(5);               // Erases all 5s
ms.erase(ms.find(5));      // Erases one occurrence

// Multimap (multiple values per key)
multimap<string, int> mm;
mm.insert({"key", 1});
mm.insert({"key", 2});     // Same key, different value
auto range = mm.equal_range("key"); // Get all values
\end{lstlisting}

\subsubsection{Priority Queue and Heaps}
Priority queues in C++ use comparators with reversed logic. By default, \texttt{priority\_queue<int>} creates a max-heap.

\begin{lstlisting}[caption={Basic Priority Queue}]
// Max heap (default)
priority_queue<int> maxHeap;
// Min heap using greater<int>
priority_queue<int, vector<int>, greater<int>> minHeap;
// Custom comparator for complex types
struct Compare {
    bool operator()(const Point& a, const Point& b) {
        // Note: reversed logic compared to set/map
        if (a.x != b.x) return a.x > b.x;
        return a.y > b.y;
    }
};
priority_queue<Point, vector<Point>, Compare> pq;
\end{lstlisting}



\subsubsection{Stack and Queue}
\begin{lstlisting}[caption={Stack and Queue Operations}]
// Stack (LIFO)
stack<int> s;
s.push(5);                  // Add element
s.pop();                    // Remove top element
s.top();                    // Access top element
s.empty();                  // Check if empty
s.size();                   // Get size
// Queue (FIFO)
queue<int> q;
q.push(5);                  // Add element
q.pop();                    // Remove front element
q.front();                  // Access front element
q.back();                   // Access back element
q.empty();                  // Check if empty
q.size();                   // Get size
// Deque (double-ended queue)
deque<int> dq;
dq.push_front(5);           // Add to front
dq.push_back(5);            // Add to back
dq.pop_front();             // Remove from front
dq.pop_back();              // Remove from back
dq.front();                 // Access front
dq.back();                  // Access back
\end{lstlisting}

\newpage

\subsubsection{Bitset}
Bitset provides space-efficient storage for boolean values.

\begin{lstlisting}[caption={Bitset Operations}]
// Bitset initialization
bitset<32> bs;              // 32-bit bitset
bitset<32> bs("1010");      // From binary string
bitset<32> bs(42);          // From integer

// Basic operations
bs.set(5);                  // Set bit at position 5
bs.reset(5);                // Reset bit at position 5
bs.flip(5);                 // Flip bit at position 5
bs.test(5);                 // Check if bit is set
bs.count();                 // Count set bits
bs.size();                  // Total number of bits

// Bitwise operations
bitset<32> a("1010"), b("1100");
auto c = a & b;             // AND
auto d = a | b;             // OR
auto e = a ^ b;             // XOR
auto f = ~a;                // NOT

// Useful for competitive programming
bs.set();                   // Set all bits
bs.reset();                 // Reset all bits
bs.flip();                  // Flip all bits
\end{lstlisting}

\newpage

\subsection{Advanced Data Structures}

\subsubsection{Segment Tree (Iterative)}
Efficient range query data structure supporting point updates and range queries.

\begin{lstlisting}[caption={Segment Tree for Range Sum}]
struct SegmentTree {
    int n;
    vector<int> tree;

    SegmentTree(const vector<int>& v) {
        n = v.size();
        tree.resize(n << 1);
        for (int i = 0; i < n; i++)
            tree[i + n] = v[i];
        for (int i = n - 1; i > 0; i--)
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
    }

    void update(int pos, int value) {
        tree[pos += n] = value;
        for (pos >>= 1; pos > 0; pos >>= 1)
            tree[pos] = tree[pos << 1] + tree[pos << 1 | 1];
    }

    int query(int l, int r) { // inclusive range [l, r]
        int res = 0;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res += tree[l++];
            if (r & 1) res += tree[--r];
        }
        return res;
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={Segment Tree Example Usage}]
int main() {
    vector<int> a = {2, 1, 5, 3, 4};
    SegmentTree st(a);

    cout << st.query(1, 3) << "\n"; // 1 + 5 + 3 = 9
    st.update(2, 0);                // a[2] = 0
    cout << st.query(1, 3) << "\n"; // 1 + 0 + 3 = 4
}
\end{lstlisting}

\newpage
\begin{lstlisting}[caption={Segment Tree for Range Maximum}]
struct SegmentTree {
    int n;
    vector<int> tree;

    SegmentTree(const vector<int>& v) {
        n = v.size();
        tree.resize(n << 1);
        for (int i = 0; i < n; i++)
            tree[i + n] = v[i];
        for (int i = n - 1; i > 0; i--)
            tree[i] = max(tree[i << 1], tree[i << 1 | 1]);
    }

    void update(int pos, int value) {
        tree[pos += n] = value;
        for (pos >>= 1; pos > 0; pos >>= 1)
            tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1]);
    }

    int query(int l, int r) { // inclusive range [l, r]
        int res = INT_MIN;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res = max(res, tree[l++]);
            if (r & 1) res = max(res, tree[--r]);
        }
        return res;
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={Segment Tree Max Example Usage}]
int main() {
    vector<int> a = {2, 1, 5, 3, 4};
    SegmentTree st(a);

    cout << st.query(1, 3) << "\n"; // max(1, 5, 3) = 5
    st.update(2, 0);                // a[2] = 0
    cout << st.query(1, 3) << "\n"; // max(1, 0, 3) = 3
}
\end{lstlisting}

\newpage

\subsubsection{Disjoint Set Union (DSU)}
Optimized union-find data structure with path compression and union by size.

\begin{lstlisting}[caption={DSU with Vector}]
struct DSU {
    vector<int> parent, size;

    DSU(int n) {
        parent.resize(n);
        size.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findParent(int x) {
        if (parent[x] == x) return x;
        return parent[x] = findParent(parent[x]);
    }

    bool sameGroup(int x, int y) {
        return findParent(x) == findParent(y);
    }

    void merge(int x, int y) {
        int rootX = findParent(x);
        int rootY = findParent(y);
        if (rootX == rootY) return;
        if (size[rootX] < size[rootY]) swap(rootX, rootY);
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={DSU Example Usage}]
int main() {
    DSU dsu(10);

    dsu.merge(1, 2);
    dsu.merge(2, 3);
    dsu.merge(4, 5);

    cout << (dsu.sameGroup(1, 3)) << "\n";  // 1 (true)
    cout << (dsu.sameGroup(1, 5)) << "\n";  // 0 (false)
}
\end{lstlisting}

\newpage
\begin{lstlisting}[caption={DSU with Unordered Map}]
struct DSUMap {
    unordered_map<int, int> parent, size;

    void makeSet(int x) {
        if (!parent.count(x)) {
            parent[x] = x;
            size[x] = 1;
        }
    }

    int findParent(int x) {
        makeSet(x);
        if (parent[x] == x) return x;
        return parent[x] = findParent(parent[x]);
    }

    bool sameGroup(int x, int y) {
        return findParent(x) == findParent(y);
    }

    void merge(int x, int y) {
        int rootX = findParent(x);
        int rootY = findParent(y);
        if (rootX == rootY) return;
        if (size[rootX] < size[rootY]) swap(rootX, rootY);
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={DSU Map Example Usage}]
int main() {
    DSUMap dsu;
    dsu.merge(100, 200);
    dsu.merge(200, 300);
    dsu.merge(400, 500);

    cout << dsu.sameGroup(100, 300) << "\n"; // 1 (true)
    cout << dsu.sameGroup(100, 500) << "\n"; // 0 (false)
}
\end{lstlisting}



\section{Graph Algorithms}

\subsection{Depth-First Search (DFS)}
Depth-First Search is a graph traversal algorithm that explores as far as possible along each branch before backtracking.

\begin{lstlisting}[caption={DFS Implementation}]
vector<vector<int>> graph;  // Adjacency list
vector<bool> visited;

void dfs(int node) {
    visited[node] = true;
    cout << node << " ";  // Process node
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
}

// Initialize and run DFS
void runDFS(int start, int n) {
    graph.resize(n);
    visited.resize(n, false);
    dfs(start);
}
\end{lstlisting}

\subsubsection{DFS Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(V + E) where V = vertices, E = edges
\item \textbf{Space Complexity}: O(V) for recursion stack
\item \textbf{Use Cases}: Exploring all possibilities, backtracking, connected components
\item \textbf{Recursive Nature}: Uses recursion, can cause stack overflow for very deep graphs
\end{itemize}

\newpage
\begin{lstlisting}[caption={DFS with Connected Components}]
vector<vector<int>> graph;
vector<bool> visited;

void dfs(int node) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
}

int countComponents(int n) {
    visited.resize(n, false);
    int components = 0;
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i);
            components++;
        }
    }
    return components;
}
\end{lstlisting}

\subsubsection{Connected Components Notes}
\begin{itemize}
\item \textbf{Application}: Finding number of disconnected subgraphs
\item \textbf{Algorithm}: Run DFS from each unvisited node
\item \textbf{Result}: Each DFS call discovers one connected component
\item \textbf{Complexity}: Still O(V + E) as each node/edge visited once
\end{itemize}

\newpage
\subsection{Breadth-First Search (BFS)}
Breadth-First Search explores all vertices at the present depth before moving to vertices at the next depth level.

\begin{lstlisting}[caption={BFS Implementation}]
vector<vector<int>> graph;  // Adjacency list
vector<bool> visited;

void bfs(int start) {
    queue<int> q;
    q.push(start);
    visited[start] = true;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";  // Process node
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

// Initialize and run BFS
void runBFS(int start, int n) {
    graph.resize(n);
    visited.resize(n, false);
    bfs(start);
}
\end{lstlisting}

\subsubsection{BFS Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(V + E) where V = vertices, E = edges
\item \textbf{Space Complexity}: O(V) for queue
\item \textbf{Use Cases}: Shortest path in unweighted graphs, level-order traversal
\item \textbf{Queue-based}: Uses queue, explores level by level
\end{itemize}

\newpage
\begin{lstlisting}[caption={BFS with Distance Calculation}]
vector<vector<int>> graph;
vector<int> distance;

void bfsWithDistance(int start, int n) {
    queue<int> q;
    distance.resize(n, -1);
    
    q.push(start);
    distance[start] = 0;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        for (int neighbor : graph[node]) {
            if (distance[neighbor] == -1) {
                distance[neighbor] = distance[node] + 1;
                q.push(neighbor);
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Distance BFS Notes}
\begin{itemize}
\item \textbf{Shortest Path}: Guarantees shortest path in unweighted graphs
\item \textbf{Distance Array}: Stores minimum distance from start to each node
\item \textbf{Level Order}: Nodes at same distance processed together
\item \textbf{Application}: Network routing, social network analysis
\end{itemize}

\newpage
\subsection{Dijkstra's Algorithm}
Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph.

\begin{lstlisting}[caption={Dijkstra's Algorithm}]
vector<vector<pair<int, int>>> graph;  // {neighbor, weight}
vector<int> distance;

void dijkstra(int start, int n) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    distance.resize(n, INT_MAX);
    
    distance[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int dist = pq.top().first;
        int node = pq.top().second;
        pq.pop();
        
        if (dist > distance[node]) continue;
        
        for (auto [neighbor, weight] : graph[node]) {
            if (distance[node] + weight < distance[neighbor]) {
                distance[neighbor] = distance[node] + weight;
                pq.push({distance[neighbor], neighbor});
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Dijkstra Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O((V + E) log V) with priority queue
\item \textbf{Space Complexity}: O(V) for distance array and priority queue
\item \textbf{Requirement}: All edge weights must be non-negative
\item \textbf{Greedy Algorithm}: Always picks the closest unvisited node
\end{itemize}

\newpage
\begin{lstlisting}[caption={Dijkstra with Path Reconstruction}]
vector<vector<pair<int, int>>> graph;
vector<int> distance, parent;

void dijkstraWithPath(int start, int n) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    distance.resize(n, INT_MAX);
    parent.resize(n, -1);
    
    distance[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int dist = pq.top().first;
        int node = pq.top().second;
        pq.pop();
        
        if (dist > distance[node]) continue;
        
        for (auto [neighbor, weight] : graph[node]) {
            if (distance[node] + weight < distance[neighbor]) {
                distance[neighbor] = distance[node] + weight;
                parent[neighbor] = node;
                pq.push({distance[neighbor], neighbor});
            }
        }
    }
}

vector<int> getPath(int end) {
    vector<int> path;
    for (int node = end; node != -1; node = parent[node]) {
        path.push_back(node);
    }
    reverse(path.begin(), path.end());
    return path;
}
\end{lstlisting}

\subsubsection{Path Reconstruction Notes}
\begin{itemize}
\item \textbf{Parent Array}: Stores predecessor of each node in shortest path
\item \textbf{Path Recovery}: Backtrack from destination to source
\item \textbf{Reverse Order}: Path is built backwards, then reversed
\item \textbf{Application}: Navigation systems, network routing
\end{itemize}

\newpage

\subsection{Floyd-Warshall Algorithm}
Floyd-Warshall finds shortest paths between all pairs of vertices in a weighted graph.

\begin{lstlisting}[caption={Floyd-Warshall Algorithm}]
vector<vector<int>> dist;  // Distance matrix
int n;

void floydWarshall() {
    // Initialize distance matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) dist[i][j] = 0;
            else dist[i][j] = INT_MAX;
        }
    }
    
    // Add edges
    // dist[u][v] = weight;  // Add your edges here
    
    // Floyd-Warshall algorithm
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Floyd-Warshall Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(V³) - cubic time complexity
\item \textbf{Space Complexity}: O(V²) for distance matrix
\item \textbf{All Pairs}: Finds shortest path between every pair of vertices
\item \textbf{Handles Negatives}: Can detect negative cycles
\end{itemize}

\newpage
\subsection{Topological Sort}
Topological sort orders vertices in a directed acyclic graph (DAG) so that all edges point forward.

\begin{lstlisting}[caption={Topological Sort with DFS}]
vector<vector<int>> graph;
vector<bool> visited;
vector<int> topoOrder;

void dfs(int node) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
    
    topoOrder.push_back(node);
}

vector<int> topologicalSort(int n) {
    visited.resize(n, false);
    topoOrder.clear();
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i);
        }
    }
    
    reverse(topoOrder.begin(), topoOrder.end());
    return topoOrder;
}
\end{lstlisting}

\subsubsection{DFS Topological Sort Notes}
\begin{itemize}
\item \textbf{Post-order DFS}: Add node after visiting all neighbors
\item \textbf{Reverse Result}: Final order is reversed DFS post-order
\item \textbf{Requirement}: Graph must be a DAG (no cycles)
\item \textbf{Application}: Build order, dependency resolution
\end{itemize}

\newpage
\begin{lstlisting}[caption={Topological Sort with Kahn's Algorithm}]
vector<vector<int>> graph;
vector<int> inDegree;

vector<int> kahnTopologicalSort(int n) {
    queue<int> q;
    vector<int> result;
    
    // Calculate in-degrees
    inDegree.resize(n, 0);
    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }
    
    // Add nodes with in-degree 0
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    
    return result;
}
\end{lstlisting}

\subsubsection{Kahn's Algorithm Notes}
\begin{itemize}
\item \textbf{In-degree Tracking}: Count incoming edges for each node
\item \textbf{Queue-based}: Process nodes with zero in-degree
\item \textbf{Multiple Orders}: Can have multiple valid topological orders
\item \textbf{Cycle Detection}: If result size < n, graph has cycle
\end{itemize}

\newpage
\subsection{Cycle Detection}
Detecting cycles in directed and undirected graphs.

\begin{lstlisting}[caption={Cycle Detection in Undirected Graph}]
vector<vector<int>> graph;
vector<bool> visited;

bool hasCycleUndirected(int node, int parent) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            if (hasCycleUndirected(neighbor, node)) {
                return true;
            }
        } else if (neighbor != parent) {
            return true;
        }
    }
    return false;
}

bool detectCycleUndirected(int n) {
    visited.resize(n, false);
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            if (hasCycleUndirected(i, -1)) {
                return true;
            }
        }
    }
    return false;
}
\end{lstlisting}

\subsubsection{Undirected Cycle Detection Notes}
\begin{itemize}
\item \textbf{Parent Tracking}: Avoid revisiting parent node
\item \textbf{Back Edge}: Cycle if neighbor is visited but not parent
\item \textbf{DFS-based}: Uses DFS to explore graph
\item \textbf{Application}: Validating trees, network topology
\end{itemize}

\newpage
\begin{lstlisting}[caption={Cycle Detection in Directed Graph}]
vector<vector<int>> graph;
vector<bool> visited, recStack;

bool hasCycleDirected(int node) {
    visited[node] = true;
    recStack[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            if (hasCycleDirected(neighbor)) {
                return true;
            }
        } else if (recStack[neighbor]) {
            return true;
        }
    }
    
    recStack[node] = false;
    return false;
}

bool detectCycleDirected(int n) {
    visited.resize(n, false);
    recStack.resize(n, false);
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            if (hasCycleDirected(i)) {
                return true;
            }
        }
    }
    return false;
}
\end{lstlisting}

\subsubsection{Directed Cycle Detection Notes}
\begin{itemize}
\item \textbf{Recursion Stack}: Track nodes in current recursion path
\item \textbf{Back Edge}: Cycle if neighbor is in recursion stack
\item \textbf{Two Arrays}: visited for all nodes, recStack for current path
\item \textbf{Application}: Deadlock detection, DAG validation
\end{itemize}

\newpage

\subsection{Important Notes}

\subsubsection{Graph Representation}
\begin{itemize}
\item \textbf{Adjacency List}: Space O(V + E), good for sparse graphs
\item \textbf{Adjacency Matrix}: Space O(V²), good for dense graphs
\item \textbf{Edge List}: Space O(E), useful for some algorithms
\end{itemize}

\subsubsection{Algorithm Complexities}
\begin{itemize}
\item \textbf{DFS/BFS}: Time O(V + E), Space O(V)
\item \textbf{Dijkstra}: Time O((V + E) log V), Space O(V)
\item \textbf{Floyd-Warshall}: Time O(V³), Space O(V²)
\item \textbf{Topological Sort}: Time O(V + E), Space O(V)
\item \textbf{Cycle Detection}: Time O(V + E), Space O(V)
\end{itemize}

\subsubsection{Usage Tips}
\begin{itemize}
\item Use DFS for exploring all possibilities, backtracking problems
\item Use BFS for shortest path in unweighted graphs, level-order traversal
\item Use Dijkstra for shortest path in weighted graphs with positive weights
\item Use Floyd-Warshall for all-pairs shortest path or detecting negative cycles
\item Use Topological Sort for dependency resolution, build order problems
\item Use Cycle Detection for validating DAGs, detecting deadlocks
\end{itemize}


\end{document}
