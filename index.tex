\documentclass[11pt,a4paper]{article}

% Essential packages first
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}  % Better font handling

% Basic formatting packages
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{array}
\usepackage{booktabs}

% Math and graphics
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}

% Colors and listings
\usepackage{xcolor}
\usepackage{listings}

% Table of contents
\usepackage{tocloft}

% Hyperref should be last
\usepackage{hyperref}
\hypersetup{
    pdftitle={Competitive Programming Reference},
    pdfauthor={TryOmar},
    pdfsubject={Competitive Programming Algorithms and Data Structures},
    pdfkeywords={competitive programming, algorithms, data structures},
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=red
}

% Page geometry
\geometry{
    paper=a4paper,
    left=2cm,
    right=2cm,
    top=2.5cm,
    bottom=2.5cm,
    headheight=15pt,
    includehead,
    includefoot
}

% Code listing setup
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    captionpos=t,
    backgroundcolor=\color{gray!10},
    aboveskip=2em,
    belowskip=2em
}

% Remove listing prefix from captions
\renewcommand{\lstlistingname}{}
\renewcommand{\lstlistlistingname}{}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textsc{Competitive Programming Reference}}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Title formatting
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Table of contents setup
\renewcommand{\cftsecfont}{\bfseries}
\renewcommand{\cftsubsecfont}{\normalsize}

\begin{document}

% Title page
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge\bfseries Competitive Programming Reference\par}
    \vspace{1cm}
    
    {\Large TryOmar's Algorithm Collection\par}
    \vspace{2cm}
    
    {\large A comprehensive collection of algorithms, data structures, and templates\par}
    \vspace{1cm}
    
    {\large \today\par}
    
    \vfill
    
    {\large \textsc{Generated from Markdown Reference}\par}
\end{titlepage}

% Table of contents
\tableofcontents
\newpage

% Introduction
\section{Introduction}
This document contains a comprehensive collection of algorithms, data structures, and templates for competitive programming. Each section includes implementation details, time complexity analysis, and usage examples.

\subsection{How to Use This Reference}
\begin{itemize}
    \item \textbf{Code Templates}: Ready-to-use implementations
    \item \textbf{Complexity Analysis}: Time and space complexity for each algorithm
    \item \textbf{Usage Examples}: Practical examples and edge cases
    \item \textbf{Notes}: Important implementation details and optimizations
\end{itemize}

\vspace{1cm}

\newpage

\section{Data Structures}

\subsection{STL Basics}
This section covers the essential C++ Standard Template Library (STL) data structures commonly used in competitive programming.

\subsubsection{Important STL Concepts}

\begin{itemize}
\item \textbf{Containers}: Data structures that hold objects (vector, set, map, etc.)
\item \textbf{Iterators}: Objects that point to elements in containers
\item \textbf{Algorithms}: Functions that operate on containers (sort, find, etc.)
\item \textbf{Function Objects}: Objects that can be called like functions
\item \textbf{Allocators}: Manage memory allocation for containers
\end{itemize}

\subsubsection{Common STL Operations}
\begin{itemize}
\item \textbf{Insertion}: \texttt{insert()}, \texttt{push\_back()}, \texttt{emplace()}
\item \textbf{Deletion}: \texttt{erase()}, \texttt{pop\_back()}, \texttt{clear()}
\item \textbf{Access}: \texttt{at()}, \texttt{operator[]}, \texttt{front()}, \texttt{back()}
\item \textbf{Size}: \texttt{size()}, \texttt{empty()}, \texttt{capacity()}
\item \textbf{Iteration}: Range-based for loops, iterators, \texttt{begin()}, \texttt{end()}
\end{itemize}

\subsubsection{Performance Considerations}
\begin{itemize}
\item \textbf{Vector}: O(1) amortized insertion at end, O(n) insertion in middle
\item \textbf{Set/Map}: O(log n) for insert, delete, search (Red-Black tree)
\item \textbf{Unordered Set/Map}: O(1) average case, O(n) worst case (hash table)
\item \textbf{Stack/Queue}: O(1) for push/pop operations
\item \textbf{Priority Queue}: O(log n) for push/pop operations
\end{itemize}

\subsubsection{Memory Management}
\begin{itemize}
\item \textbf{Vector}: Automatically grows, use \texttt{reserve()} to pre-allocate
\item \textbf{Set/Map}: Memory allocated per node, efficient for sparse data
\item \textbf{Unordered}: Memory allocated in buckets, good for dense data
\item \textbf{Stack/Queue}: Memory allocated as needed, efficient for LIFO/FIFO
\end{itemize}

\newpage

\subsubsection{Vectors and Arrays}

\begin{lstlisting}[caption={Basic Vector Operations}]
// Vector initialization
vector<int> v;                // Empty vector
vector<int> v(5);            // Size 5, initialized with 0s
vector<int> v(5, 2);         // Size 5, initialized with 2s
vector<int> v = {1, 2, 3};   // Direct initialization

// Basic operations
v.push_back(4);              // Add element to end
v.pop_back();                // Remove last element
v.size();                    // Get current size
v.empty();                   // Check if empty
v.front();                   // First element
v.back();                    // Last element
v.clear();                   // Remove all elements

// Access and iteration
for(int i = 0; i < v.size(); i++) {
    cout << v[i] << " ";     // Using index
}
for(int x : v) {             // Range-based for loop
    cout << x << " ";
}
\end{lstlisting}

\begin{lstlisting}[caption={2D Vector Operations}]
// 2D vector initialization
vector<vector<int>> grid(n, vector<int>(m));    // n x m grid
vector<vector<int>> grid = {                    // Direct init
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// Access elements
grid[i][j] = value;          // Set value
int value = grid[i][j];      // Get value

// Common operations
for(int i = 0; i < grid.size(); i++) {
    for(int j = 0; j < grid[i].size(); j++) {
        cout << grid[i][j] << " ";
    }
    cout << "\n";
}
\end{lstlisting}

\subsubsection{Sets and Maps}

\begin{lstlisting}[caption={Set and Unordered Set}]
// Set (ordered)
set<int> s;                  // Ordered unique elements
s.insert(5);                 // O(log n) insertion
s.erase(5);                 // O(log n) deletion
auto it = s.find(5);        // O(log n) search
auto it = s.lower_bound(5); // First element >= 5
auto it = s.upper_bound(5); // First element > 5

// Unordered Set (hash table)
unordered_set<int> us;      // Unordered unique elements
us.insert(5);               // O(1) average case
us.erase(5);               // O(1) average case
auto it = us.find(5);      // O(1) average case
\end{lstlisting}

\begin{lstlisting}[caption={Map and Unordered Map}]
// Map (ordered)
map<string, int> m;         // Key-value pairs
m["apple"] = 5;             // O(log n) insertion
m.erase("apple");          // O(log n) deletion
auto it = m.find("apple"); // O(log n) search

// Unordered Map (hash table)
unordered_map<string, int> um; // Hash table
um["apple"] = 5;              // O(1) average case
um.erase("apple");           // O(1) average case
auto it = um.find("apple");  // O(1) average case
\end{lstlisting}


\begin{lstlisting}[caption={Multiset and Multimap Operations}]
// Multiset (allows duplicates)
multiset<int> ms;
ms.insert(5);               // Can insert multiple 5s
ms.erase(5);               // Erases all 5s
ms.erase(ms.find(5));      // Erases one occurrence

// Multimap (multiple values per key)
multimap<string, int> mm;
mm.insert({"key", 1});
mm.insert({"key", 2});     // Same key, different value
auto range = mm.equal_range("key"); // Get all values
\end{lstlisting}

\subsubsection{Priority Queue and Heaps}
Priority queues in C++ use comparators with reversed logic. By default, \texttt{priority\_queue<int>} creates a max-heap.

\begin{lstlisting}[caption={Basic Priority Queue}]
// Max heap (default)
priority_queue<int> maxHeap;
// Min heap using greater<int>
priority_queue<int, vector<int>, greater<int>> minHeap;
// Custom comparator for complex types
struct Compare {
    bool operator()(const Point& a, const Point& b) {
        // Note: reversed logic compared to set/map
        if (a.x != b.x) return a.x > b.x;
        return a.y > b.y;
    }
};
priority_queue<Point, vector<Point>, Compare> pq;
\end{lstlisting}



\subsubsection{Stack and Queue}
\begin{lstlisting}[caption={Stack and Queue Operations}]
// Stack (LIFO)
stack<int> s;
s.push(5);                  // Add element
s.pop();                    // Remove top element
s.top();                    // Access top element
s.empty();                  // Check if empty
s.size();                   // Get size
// Queue (FIFO)
queue<int> q;
q.push(5);                  // Add element
q.pop();                    // Remove front element
q.front();                  // Access front element
q.back();                   // Access back element
q.empty();                  // Check if empty
q.size();                   // Get size
// Deque (double-ended queue)
deque<int> dq;
dq.push_front(5);           // Add to front
dq.push_back(5);            // Add to back
dq.pop_front();             // Remove from front
dq.pop_back();              // Remove from back
dq.front();                 // Access front
dq.back();                  // Access back
\end{lstlisting}

\newpage

\subsubsection{Bitset}
Bitset provides space-efficient storage for boolean values.

\begin{lstlisting}[caption={Bitset Operations}]
// Bitset initialization
bitset<32> bs;              // 32-bit bitset
bitset<32> bs("1010");      // From binary string
bitset<32> bs(42);          // From integer

// Basic operations
bs.set(5);                  // Set bit at position 5
bs.reset(5);                // Reset bit at position 5
bs.flip(5);                 // Flip bit at position 5
bs.test(5);                 // Check if bit is set
bs.count();                 // Count set bits
bs.size();                  // Total number of bits

// Bitwise operations
bitset<32> a("1010"), b("1100");
auto c = a & b;             // AND
auto d = a | b;             // OR
auto e = a ^ b;             // XOR
auto f = ~a;                // NOT

// Useful for competitive programming
bs.set();                   // Set all bits
bs.reset();                 // Reset all bits
bs.flip();                  // Flip all bits
\end{lstlisting}

\newpage

\subsection{Advanced Data Structures}

\subsubsection{Segment Tree (Iterative)}
Efficient range query data structure supporting point updates and range queries.

\begin{lstlisting}[caption={Segment Tree for Range Sum}]
struct SegmentTree {
    int n;
    vector<int> tree;

    SegmentTree(const vector<int>& v) {
        n = v.size();
        tree.resize(n << 1);
        for (int i = 0; i < n; i++)
            tree[i + n] = v[i];
        for (int i = n - 1; i > 0; i--)
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
    }

    void update(int pos, int value) {
        tree[pos += n] = value;
        for (pos >>= 1; pos > 0; pos >>= 1)
            tree[pos] = tree[pos << 1] + tree[pos << 1 | 1];
    }

    int query(int l, int r) { // inclusive range [l, r]
        int res = 0;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res += tree[l++];
            if (r & 1) res += tree[--r];
        }
        return res;
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={Segment Tree Example Usage}]
int main() {
    vector<int> a = {2, 1, 5, 3, 4};
    SegmentTree st(a);

    cout << st.query(1, 3) << "\n"; // 1 + 5 + 3 = 9
    st.update(2, 0);                // a[2] = 0
    cout << st.query(1, 3) << "\n"; // 1 + 0 + 3 = 4
}
\end{lstlisting}

\newpage
\begin{lstlisting}[caption={Segment Tree for Range Maximum}]
struct SegmentTree {
    int n;
    vector<int> tree;

    SegmentTree(const vector<int>& v) {
        n = v.size();
        tree.resize(n << 1);
        for (int i = 0; i < n; i++)
            tree[i + n] = v[i];
        for (int i = n - 1; i > 0; i--)
            tree[i] = max(tree[i << 1], tree[i << 1 | 1]);
    }

    void update(int pos, int value) {
        tree[pos += n] = value;
        for (pos >>= 1; pos > 0; pos >>= 1)
            tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1]);
    }

    int query(int l, int r) { // inclusive range [l, r]
        int res = INT_MIN;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res = max(res, tree[l++]);
            if (r & 1) res = max(res, tree[--r]);
        }
        return res;
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={Segment Tree Max Example Usage}]
int main() {
    vector<int> a = {2, 1, 5, 3, 4};
    SegmentTree st(a);

    cout << st.query(1, 3) << "\n"; // max(1, 5, 3) = 5
    st.update(2, 0);                // a[2] = 0
    cout << st.query(1, 3) << "\n"; // max(1, 0, 3) = 3
}
\end{lstlisting}

\newpage

\subsubsection{Disjoint Set Union (DSU)}
Optimized union-find data structure with path compression and union by size.

\begin{lstlisting}[caption={DSU with Vector}]
struct DSU {
    vector<int> parent, size;

    DSU(int n) {
        parent.resize(n);
        size.resize(n);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findParent(int x) {
        if (parent[x] == x) return x;
        return parent[x] = findParent(parent[x]);
    }

    bool sameGroup(int x, int y) {
        return findParent(x) == findParent(y);
    }

    void merge(int x, int y) {
        int rootX = findParent(x);
        int rootY = findParent(y);
        if (rootX == rootY) return;
        if (size[rootX] < size[rootY]) swap(rootX, rootY);
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={DSU Example Usage}]
int main() {
    DSU dsu(10);

    dsu.merge(1, 2);
    dsu.merge(2, 3);
    dsu.merge(4, 5);

    cout << (dsu.sameGroup(1, 3)) << "\n";  // 1 (true)
    cout << (dsu.sameGroup(1, 5)) << "\n";  // 0 (false)
}
\end{lstlisting}

\newpage
\begin{lstlisting}[caption={DSU with Unordered Map}]
struct DSUMap {
    unordered_map<int, int> parent, size;

    void makeSet(int x) {
        if (!parent.count(x)) {
            parent[x] = x;
            size[x] = 1;
        }
    }

    int findParent(int x) {
        makeSet(x);
        if (parent[x] == x) return x;
        return parent[x] = findParent(parent[x]);
    }

    bool sameGroup(int x, int y) {
        return findParent(x) == findParent(y);
    }

    void merge(int x, int y) {
        int rootX = findParent(x);
        int rootY = findParent(y);
        if (rootX == rootY) return;
        if (size[rootX] < size[rootY]) swap(rootX, rootY);
        parent[rootY] = rootX;
        size[rootX] += size[rootY];
    }
};
\end{lstlisting}

\begin{lstlisting}[caption={DSU Map Example Usage}]
int main() {
    DSUMap dsu;
    dsu.merge(100, 200);
    dsu.merge(200, 300);
    dsu.merge(400, 500);

    cout << dsu.sameGroup(100, 300) << "\n"; // 1 (true)
    cout << dsu.sameGroup(100, 500) << "\n"; // 0 (false)
}
\end{lstlisting}

\newpage

\section{Graph Algorithms}

\subsection{Depth-First Search (DFS)}
Depth-First Search is a graph traversal algorithm that explores as far as possible along each branch before backtracking.

\begin{lstlisting}[caption={DFS Implementation}]
vector<vector<int>> graph;  // Adjacency list
vector<bool> visited;

void dfs(int node) {
    visited[node] = true;
    cout << node << " ";  // Process node
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
}

// Initialize and run DFS
void runDFS(int start, int n) {
    graph.resize(n);
    visited.resize(n, false);
    dfs(start);
}
\end{lstlisting}

\subsubsection{DFS Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(V + E) where V = vertices, E = edges
\item \textbf{Space Complexity}: O(V) for recursion stack
\item \textbf{Use Cases}: Exploring all possibilities, backtracking, connected components
\item \textbf{Recursive Nature}: Uses recursion, can cause stack overflow for very deep graphs
\end{itemize}

\newpage
\begin{lstlisting}[caption={DFS with Connected Components}]
vector<vector<int>> graph;
vector<bool> visited;

void dfs(int node) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
}

int countComponents(int n) {
    visited.resize(n, false);
    int components = 0;
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i);
            components++;
        }
    }
    return components;
}
\end{lstlisting}

\subsubsection{Connected Components Notes}
\begin{itemize}
\item \textbf{Application}: Finding number of disconnected subgraphs
\item \textbf{Algorithm}: Run DFS from each unvisited node
\item \textbf{Result}: Each DFS call discovers one connected component
\item \textbf{Complexity}: Still O(V + E) as each node/edge visited once
\end{itemize}

\newpage
\subsection{Breadth-First Search (BFS)}
Breadth-First Search explores all vertices at the present depth before moving to vertices at the next depth level.

\begin{lstlisting}[caption={BFS Implementation}]
vector<vector<int>> graph;  // Adjacency list
vector<bool> visited;

void bfs(int start) {
    queue<int> q;
    q.push(start);
    visited[start] = true;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";  // Process node
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

// Initialize and run BFS
void runBFS(int start, int n) {
    graph.resize(n);
    visited.resize(n, false);
    bfs(start);
}
\end{lstlisting}

\subsubsection{BFS Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(V + E) where V = vertices, E = edges
\item \textbf{Space Complexity}: O(V) for queue
\item \textbf{Use Cases}: Shortest path in unweighted graphs, level-order traversal
\item \textbf{Queue-based}: Uses queue, explores level by level
\end{itemize}

\newpage
\begin{lstlisting}[caption={BFS with Distance Calculation}]
vector<vector<int>> graph;
vector<int> distance;

void bfsWithDistance(int start, int n) {
    queue<int> q;
    distance.resize(n, -1);
    
    q.push(start);
    distance[start] = 0;
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        
        for (int neighbor : graph[node]) {
            if (distance[neighbor] == -1) {
                distance[neighbor] = distance[node] + 1;
                q.push(neighbor);
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Distance BFS Notes}
\begin{itemize}
\item \textbf{Shortest Path}: Guarantees shortest path in unweighted graphs
\item \textbf{Distance Array}: Stores minimum distance from start to each node
\item \textbf{Level Order}: Nodes at same distance processed together
\item \textbf{Application}: Network routing, social network analysis
\end{itemize}

\newpage
\subsection{Dijkstra's Algorithm}
Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph.

\begin{lstlisting}[caption={Dijkstra's Algorithm}]
vector<vector<pair<int, int>>> graph;  // {neighbor, weight}
vector<int> distance;

void dijkstra(int start, int n) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    distance.resize(n, INT_MAX);
    
    distance[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int dist = pq.top().first;
        int node = pq.top().second;
        pq.pop();
        
        if (dist > distance[node]) continue;
        
        for (auto [neighbor, weight] : graph[node]) {
            if (distance[node] + weight < distance[neighbor]) {
                distance[neighbor] = distance[node] + weight;
                pq.push({distance[neighbor], neighbor});
            }
        }
    }
}
\end{lstlisting}

\subsubsection{Dijkstra Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O((V + E) log V) with priority queue
\item \textbf{Space Complexity}: O(V) for distance array and priority queue
\item \textbf{Requirement}: All edge weights must be non-negative
\item \textbf{Greedy Algorithm}: Always picks the closest unvisited node
\end{itemize}

\newpage
\begin{lstlisting}[caption={Dijkstra with Path Reconstruction}]
vector<vector<pair<int, int>>> graph;
vector<int> distance, parent;

void dijkstraWithPath(int start, int n) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    distance.resize(n, INT_MAX);
    parent.resize(n, -1);
    
    distance[start] = 0;
    pq.push({0, start});
    
    while (!pq.empty()) {
        int dist = pq.top().first;
        int node = pq.top().second;
        pq.pop();
        
        if (dist > distance[node]) continue;
        
        for (auto [neighbor, weight] : graph[node]) {
            if (distance[node] + weight < distance[neighbor]) {
                distance[neighbor] = distance[node] + weight;
                parent[neighbor] = node;
                pq.push({distance[neighbor], neighbor});
            }
        }
    }
}

vector<int> getPath(int end) {
    vector<int> path;
    for (int node = end; node != -1; node = parent[node]) {
        path.push_back(node);
    }
    reverse(path.begin(), path.end());
    return path;
}
\end{lstlisting}

\subsubsection{Path Reconstruction Notes}
\begin{itemize}
\item \textbf{Parent Array}: Stores predecessor of each node in shortest path
\item \textbf{Path Recovery}: Backtrack from destination to source
\item \textbf{Reverse Order}: Path is built backwards, then reversed
\item \textbf{Application}: Navigation systems, network routing
\end{itemize}

\newpage

\subsection{Floyd-Warshall Algorithm}
Floyd-Warshall finds shortest paths between all pairs of vertices in a weighted graph.

\begin{lstlisting}[caption={Floyd-Warshall Algorithm}]
int main() {
    int INF = 1e9;
    int n = 4;
    vector<vector<int>> mat = {
        {0, 3, INF, 7},
        {8, 0, 2, INF},
        {5, INF, 0, 1},
        {2, INF, INF, 0}
    };

    for (int mid = 0; mid < n; mid++)
        for (int from = 0; from < n; from++)
            for (int to = 0; to < n; to++)
                mat[from][to] = min(mat[from][to], mat[from][mid] + mat[mid][to]);

    for (int from = 0; from < n; from++) {
        for (int to = 0; to < n; to++)
            cout << (mat[from][to] == INF ? -1 : mat[from][to]) << " ";
        cout << "\n";
    }
}
\end{lstlisting}

\subsubsection{Floyd-Warshall Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(V³) - cubic time complexity
\item \textbf{Space Complexity}: O(V²) for distance matrix
\item \textbf{All Pairs}: Finds shortest path between every pair of vertices
\item \textbf{Handles Negatives}: Can detect negative cycles
\end{itemize}

\newpage
\subsection{Topological Sort}
Topological sort orders vertices in a directed acyclic graph (DAG) so that all edges point forward.

\begin{lstlisting}[caption={Topological Sort with DFS}]
vector<vector<int>> graph;
vector<bool> visited;
vector<int> topoOrder;

void dfs(int node) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor);
        }
    }
    
    topoOrder.push_back(node);
}

vector<int> topologicalSort(int n) {
    visited.resize(n, false);
    topoOrder.clear();
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i);
        }
    }
    
    reverse(topoOrder.begin(), topoOrder.end());
    return topoOrder;
}
\end{lstlisting}

\subsubsection{DFS Topological Sort Notes}
\begin{itemize}
\item \textbf{Post-order DFS}: Add node after visiting all neighbors
\item \textbf{Reverse Result}: Final order is reversed DFS post-order
\item \textbf{Requirement}: Graph must be a DAG (no cycles)
\item \textbf{Application}: Build order, dependency resolution
\end{itemize}

\newpage
\begin{lstlisting}[caption={Topological Sort with Kahn's Algorithm}]
vector<vector<int>> graph;
vector<int> inDegree;

vector<int> kahnTopologicalSort(int n) {
    queue<int> q;
    vector<int> result;
    
    // Calculate in-degrees
    inDegree.resize(n, 0);
    for (int i = 0; i < n; i++) {
        for (int neighbor : graph[i]) {
            inDegree[neighbor]++;
        }
    }
    
    // Add nodes with in-degree 0
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            q.push(i);
        }
    }
    
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            inDegree[neighbor]--;
            if (inDegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    
    return result;
}
\end{lstlisting}

\subsubsection{Kahn's Algorithm Notes}
\begin{itemize}
\item \textbf{In-degree Tracking}: Count incoming edges for each node
\item \textbf{Queue-based}: Process nodes with zero in-degree
\item \textbf{Multiple Orders}: Can have multiple valid topological orders
\item \textbf{Cycle Detection}: If result size < n, graph has cycle
\end{itemize}

\newpage
\subsection{Cycle Detection}
Detecting cycles in directed and undirected graphs.

\begin{lstlisting}[caption={Cycle Detection in Undirected Graph}]
vector<vector<int>> graph;
vector<bool> visited;

bool hasCycleUndirected(int node, int parent) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            if (hasCycleUndirected(neighbor, node)) {
                return true;
            }
        } else if (neighbor != parent) {
            return true;
        }
    }
    return false;
}

bool detectCycleUndirected(int n) {
    visited.resize(n, false);
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            if (hasCycleUndirected(i, -1)) {
                return true;
            }
        }
    }
    return false;
}
\end{lstlisting}

\subsubsection{Undirected Cycle Detection Notes}
\begin{itemize}
\item \textbf{Parent Tracking}: Avoid revisiting parent node
\item \textbf{Back Edge}: Cycle if neighbor is visited but not parent
\item \textbf{DFS-based}: Uses DFS to explore graph
\item \textbf{Application}: Validating trees, network topology
\end{itemize}

\newpage
\begin{lstlisting}[caption={Cycle Detection in Directed Graph}]
vector<vector<int>> graph;
vector<bool> visited, recStack;

bool hasCycleDirected(int node) {
    visited[node] = true;
    recStack[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            if (hasCycleDirected(neighbor)) {
                return true;
            }
        } else if (recStack[neighbor]) {
            return true;
        }
    }
    
    recStack[node] = false;
    return false;
}

bool detectCycleDirected(int n) {
    visited.resize(n, false);
    recStack.resize(n, false);
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            if (hasCycleDirected(i)) {
                return true;
            }
        }
    }
    return false;
}
\end{lstlisting}

\subsubsection{Directed Cycle Detection Notes}
\begin{itemize}
\item \textbf{Recursion Stack}: Track nodes in current recursion path
\item \textbf{Back Edge}: Cycle if neighbor is in recursion stack
\item \textbf{Two Arrays}: visited for all nodes, recStack for current path
\item \textbf{Application}: Deadlock detection, DAG validation
\end{itemize}

\newpage

\section{Dynamic Programming}

\subsection{Longest Increasing Subsequence (LIS)}
The Longest Increasing Subsequence problem finds the longest subsequence of a given sequence such that all elements of the subsequence are sorted in increasing order.

\begin{lstlisting}[caption={LIS - 2D DP Bottom-Up Implementation}]
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> dp(n + 2, vector<int>(n + 2));

    for (int i = n - 1; i >= 0; --i) {
        for (int j = i - 1; j >= -1; --j) {
            int curr = i + 1, prev = j + 1;
            if (j == -1 || nums[i] > nums[j])
                dp[curr][prev] = dp[curr + 1][curr] + 1;
            dp[curr][prev] = max(dp[curr][prev], dp[curr + 1][prev]);
        }
    }

    // Reconstruct the LIS
    vector<int> lis;
    int i = 0, j = -1;
    while (i < n) {
        int curr = i + 1, prev = j + 1;
        if (dp[curr][prev] == dp[curr + 1][curr] + 1 && (j == -1 || nums[i] > nums[j])) {
            lis.push_back(nums[i]);
            j = i;
        }
        i++;
    }

    return dp[1][0];
}
\end{lstlisting}

\subsubsection{LIS 2D DP Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n²) - quadratic time
\item \textbf{Space Complexity}: O(n²) for 2D DP table
\item \textbf{State Definition}: dp[i+1][j+1] represents LIS from index i with last element at j
\item \textbf{Reconstruction}: Can reconstruct the actual LIS sequence
\item \textbf{Usage}: Use for understanding and simple cases
\end{itemize}

\newpage
\begin{lstlisting}[caption={LIS - 1D DP Bottom-Up Implementation}]
int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    vector<int> dp(n, 1);
    for (int i = n - 1; i >= 0; --i)
        for (int j = i + 1; j < n; ++j)
            if (nums[j] > nums[i])
                dp[i] = max(dp[i], dp[j] + 1);

    // Reconstruct the LIS
    int maxLen = *max_element(dp.begin(), dp.end());
    vector<int> lis;
    for (int i = 0; i < n && maxLen; ++i)
        if (dp[i] == maxLen) {
            lis.push_back(nums[i]);
            --maxLen;
        }

    return *max_element(dp.begin(), dp.end());
}
\end{lstlisting}

\subsubsection{LIS 1D DP Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n²) with memoization
\item \textbf{Space Complexity}: O(n) for 1D DP array
\item \textbf{State Definition}: dp[i] is length of LIS ending at index i
\item \textbf{Base Case}: dp[i] = 1 for all i (single element is valid LIS)
\item \textbf{Advantage}: More space efficient than 2D approach
\end{itemize}

\newpage
\begin{lstlisting}[caption={LIS - Recursive Implementation}]
int lengthOfLIS(const vector<int>& nums) {
    int n = nums.size();
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));

    function<int(int, int)> calculateLIS = [&](int cur, int prev) {
        if (cur == n) return 0;
        int i = cur + 1, j = prev + 1;
        int& res = dp[i][j];
        if (res != -1) return res;

        if (prev == -1 || nums[cur] > nums[prev]) 
            res = max(res, 1 + calculateLIS(cur + 1, cur));

        res = max(res, calculateLIS(cur + 1, prev));

        return res;
    };

    return calculateLIS(0, -1);
}
\end{lstlisting}

\subsubsection{LIS Recursive Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n²) with memoization
\item \textbf{Space Complexity}: O(n²) for DP table and recursion stack
\item \textbf{Top-down DP}: Recursive approach with memoization
\item \textbf{Base Case}: When cur == n, return 0
\item \textbf{Memoization}: Stores results to avoid redundant calculations
\end{itemize}

\newpage
\begin{lstlisting}[caption={LIS - Binary Search Implementation}]
int lengthOfLIS(const vector<int>& a) {
    vector<int> lis;
    for (int i = 0; i < a.size(); ++i) {
        auto it = lower_bound(begin(lis), end(lis), a[i]);
        it != end(lis) ? *it = a[i] : lis.push_back(a[i]);
    }
    return lis.size();
}

// Reconstruct the actual LIS sequence
vector<int> getLIS(const vector<int>& a) {
    vector<int> lis, prev(a.size(), -1);
    for (int i = 0; i < a.size(); ++i) {
        auto it = lower_bound(begin(lis), end(lis), i, [&](int j, int k) { 
            return a[j] < a[k]; 
        });
        it != end(lis) ? *it = i : lis.push_back(i);
        if (it != begin(lis)) prev[i] = *(it - 1);
    }
    vector<int> res;
    for (int i = lis.back(); i != -1; i = prev[i]) {
        res.push_back(a[i]);
    }
    reverse(begin(res), end(res));
    return res;
}
\end{lstlisting}

\subsubsection{LIS Binary Search Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n log n) - optimal approach
\item \textbf{Space Complexity}: O(n) for LIS array and prev array
\item \textbf{Binary Search}: Uses lower\_bound for efficient insertion
\item \textbf{Optimal Solution}: Best time complexity for LIS problem
\item \textbf{Usage}: Use for optimal time complexity in practice
\item \textbf{Reconstruction}: Can reconstruct the actual LIS sequence
\end{itemize}

\newpage
\begin{lstlisting}[caption={LIS - Segment Tree Implementation}]
struct SegmentTree {
    int n;
    vector<int> tree;
    
    SegmentTree(int _n) {
        n = _n;
        tree.resize(2 * _n);
    }

    void update(int pos, int value) {
        tree[pos += n] = value;
        for (pos >>= 1; pos > 0; pos >>= 1) 
            tree[pos] = max(tree[pos << 1], tree[pos << 1 | 1]);
    }

    int query(int l, int r) {
        int res = 0;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res = max(res, tree[l++]);
            if (r & 1) res = max(res, tree[--r]);
        }
        return res;
    }
};

int lengthOfLIS(vector<int>& nums) {
    SegmentTree seg(1e5 + 1);
    int res = 0;
    for (auto i : nums) {
        i += 2e4;  // Offset to handle negative numbers
        int val = seg.query(0, i - 1) + 1;  // Find max LIS ending before i
        res = max(res, val);
        seg.update(i, val);  // Update the LIS at position i
    }
    return res;
}
\end{lstlisting}

\subsubsection{LIS Segment Tree Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n log M) where M is the range of values
\item \textbf{Space Complexity}: O(M) for segment tree
\item \textbf{Advanced Approach}: Uses segment tree for range queries
\item \textbf{Coordinate Compression}: Can handle large value ranges
\item \textbf{Usage}: Use when you need range queries or advanced applications
\item \textbf{Offset}: +2e4 handles negative numbers
\end{itemize}

\newpage

\section{Backtracking}

\subsection{Subsets}
Generate all possible subsets of a given array.

\begin{lstlisting}[caption={Subsets Implementation}]
#include <vector>
using namespace std;

vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> result;
    vector<int> subset;
    
    function<void(int)> generate = [&](int start) {
        // Add the current subset to the result
        result.push_back(subset);
        
        // Try adding each remaining element to the current subset
        for (int i = start; i < nums.size(); i++) {
            subset.push_back(nums[i]);
            generate(i + 1);
            subset.pop_back();
        }
    };
    
    generate(0);
    return result;
}
\end{lstlisting}

\subsubsection{Subsets Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(2\textsuperscript{n}) where n is the number of elements
\item \textbf{Space Complexity}: O(2\textsuperscript{n}) to store all subsets
\item \textbf{Backtracking Pattern}: Choose → Recurse → Unchoose
\item \textbf{Natural Generation}: Each recursive call decides whether to include each element
\item \textbf{Empty Set}: Includes the empty set as a valid subset
\item \textbf{No Duplicates}: Avoids duplicates by only considering elements from current index forward
\end{itemize}

\newpage
\subsection{Permutations}
Generate all possible permutations of a given array.

\begin{lstlisting}[caption={Permutations Without Duplicates}]
#include <vector>
using namespace std;

vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<vector<int>> result;
    vector<int> comb;
    vector<bool> visited(nums.size(), false);

    function<void()> permute = [&]() {
        if (comb.size() == nums.size()) {
            result.push_back(comb);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (visited[i]) continue;
            visited[i] = true;
            comb.push_back(nums[i]);
            permute();
            comb.pop_back();
            visited[i] = false;
        }
    };

    permute();
    return result;
}
\end{lstlisting}

\subsubsection{Permutations Without Duplicates Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n!) where n is the number of elements
\item \textbf{Space Complexity}: O(n!) to store all permutations
\item \textbf{Visited Array}: Tracks which elements have been used
\item \textbf{Perfect for Unique Elements}: Arrays with unique elements
\item \textbf{All Orderings}: Generates all possible orderings of input array
\item \textbf{Backtracking}: Uses visited array to prevent reusing elements
\end{itemize}

\newpage
\begin{lstlisting}[caption={Permutations With Duplicates}]
#include <vector>
#include <unordered_map>
using namespace std;

vector<vector<int>> permuteWithDuplicates(vector<int>& nums) {
    vector<vector<int>> result;
    unordered_map<int, int> counter;
    for (int num : nums) counter[num]++;

    vector<int> comb;

    function<void()> permute = [&]() {
        if (comb.size() == nums.size()) {
            result.push_back(comb);
            return;
        }
        for (auto& item : counter) {
            int num = item.first;
            int count = item.second;
            if (count == 0) continue;
            comb.push_back(num);
            counter[num]--;
            permute();
            comb.pop_back();
            counter[num]++;
        }
    };

    permute();
    return result;
}
\end{lstlisting}

\subsubsection{Permutations With Duplicates Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n! × n) due to factorial permutations and element checking
\item \textbf{Space Complexity}: O(n!) to store the resulting permutations
\item \textbf{Unordered Map}: Tracks frequency of each element
\item \textbf{Prevents Duplicates}: More efficient for inputs with repeated elements
\item \textbf{Counter Management}: Decrements and increments counter during backtracking
\item \textbf{Usage}: Use when input array contains duplicate elements
\end{itemize}

\newpage
\subsection{Combinations}
Generate all possible combinations of k elements from an array.

\begin{lstlisting}[caption={Combinations Implementation}]
#include <vector>
using namespace std;

vector<vector<int>> combinations(vector<int>& nums, int k) {
    vector<vector<int>> result;
    vector<int> comb;

    function<void(int)> combine = [&](int start) {
        if (comb.size() == k) {
            result.push_back(comb);
            return;
        }
        for (int i = start; i < nums.size(); i++) {
            comb.push_back(nums[i]);
            combine(i + 1);
            comb.pop_back();
        }
    };

    combine(0);
    return result;
}
\end{lstlisting}

\subsubsection{Combinations Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(C(n,k)) or O(n!/(k!(n-k)!)) where n is number of elements and k is size of each combination
\item \textbf{Space Complexity}: O(C(n,k)) to store all combinations
\item \textbf{Starting Index}: Uses start parameter to avoid duplicates
\item \textbf{Size Constraint}: Generates combinations of exactly size k
\item \textbf{No Reuse}: No element is used more than once in each combination
\item \textbf{Order Independent}: Unlike permutations, order doesn't matter in combinations
\end{itemize}

\newpage

\section{String Algorithms}

\subsection{C++ STL String Functions}
Essential string manipulation functions from the C++ Standard Library.

\begin{lstlisting}[caption={STL String Functions}]
#include <string>
#include <algorithm>

string s = "Hello World";
// Basic operations
s.length();                    // Get string length
s.size();                      // Same as length()
s.empty();                     // Check if empty
s.clear();                     // Clear string
// Access elements
s[0];                         // Access character
s.at(0);                      // Bounds-checked access
s.front();                     // First character
s.back();                      // Last character
// String manipulation
s.substr(0, 5);               // Substring
s.find("World");               // Find substring
s.replace(0, 5, "Hi");        // Replace substring
s.insert(5, " ");             // Insert at position
// String algorithms
reverse(s.begin(), s.end());   // Reverse string
sort(s.begin(), s.end());      // Sort characters
transform(s.begin(), s.end(), s.begin(), ::tolower); // To lowercase
transform(s.begin(), s.end(), s.begin(), ::toupper); // To uppercase
// String concatenation
string s1 = "Hello";
string s2 = "World";
string result = s1 + " " + s2; // Concatenation
s1.append(s2);                 // Append to string
s1 += s2;                      // Append operator
\end{lstlisting}

\subsubsection{STL String Notes}
\begin{itemize}
\item \textbf{Time Complexity}: Most operations O(1) or O(n)
\item \textbf{Memory Efficient}: String uses dynamic allocation
\item \textbf{STL Algorithms}: Can use all STL algorithms on strings
\item \textbf{Character Access}: Direct indexing and bounds-checked access
\end{itemize}

\newpage
\subsection{Longest Substring Without Repeating Characters}
Find the length of the longest substring without repeating characters.

\begin{lstlisting}[caption={Longest Substring Without Repeating Characters}]
int lengthOfLongestSubstring(string s) {
    vector<int> charIndex(128, -1);  // ASCII characters
    int maxLength = 0;
    int start = 0;
    
    for (int end = 0; end < s.length(); end++) {
        char currentChar = s[end];
        
        // If character already seen, update start
        if (charIndex[currentChar] >= start) {
            start = charIndex[currentChar] + 1;
        }
        
        charIndex[currentChar] = end;
        maxLength = max(maxLength, end - start + 1);
    }
    
    return maxLength;
}
\end{lstlisting}

\subsubsection{Longest Substring Notes}
\begin{itemize}
\item \textbf{Sliding Window}: Uses two pointers technique
\item \textbf{Time Complexity}: O(n) where n is string length
\item \textbf{Space Complexity}: O(1) for fixed alphabet size
\item \textbf{Character Tracking}: Uses array to track last position
\end{itemize}

\newpage
\subsection{Trie (Prefix Tree)}
A trie is a tree-like data structure used to store a dynamic set of strings.

\begin{lstlisting}[caption={Trie Node Implementation}]
struct TrieNode {
    vector<TrieNode*> children;
    bool isEndOfWord;
    
    TrieNode() {
        children.resize(26, nullptr);
        isEndOfWord = false;
    }
};
\end{lstlisting}

\subsubsection{Trie Node Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(1) for insertion and search
\item \textbf{Space Complexity}: O(ALPHABET\_SIZE $\times$ N $\times$ M)
\item \textbf{Applications}: Prefix matching, autocomplete
\end{itemize}

\newpage

\begin{lstlisting}[caption={Trie Implementation}]

class Trie {
private:
    TrieNode* root;
    
public:
    Trie() { root = new TrieNode(); }
    void insert(string word) {
        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (!node->children[index])  node->children[index] = new TrieNode();
            node = node->children[index];
        }
        node->isEndOfWord = true;
    }
    bool search(string word) {
        TrieNode* node = root;
        for (char c : word) {
            int index = c - 'a';
            if (!node->children[index])  return false;
            node = node->children[index];
        }
        return node->isEndOfWord;
    }
    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            int index = c - 'a';
            if (!node->children[index])  return false;
            node = node->children[index];
        }
        return true;
    }
};
\end{lstlisting}

\subsubsection{Trie Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(m) where m is string length
\item \textbf{Space Complexity}: O(ALPHABET\_SIZE $\times$ N $\times$ M)
\item \textbf{Applications}: Prefix matching, autocomplete
\item \textbf{Memory Usage}: Can be memory intensive for large datasets
\end{itemize}

\newpage
\section{Mathematics}

\subsection{Fast Power (Binary Exponentiation)}
Efficiently compute large powers using binary exponentiation.


\begin{lstlisting}[caption={Binary Exponentiation - Iterative}]
int64_t power(int64_t base, int64_t exp) {
    int64_t result = 1;
    while (exp > 0) {
        if (exp & 1) result *= base;
        base *= base;
        exp >>= 1;
    }
    return result;
}
\end{lstlisting}

\begin{lstlisting}[caption={Modular Exponentiation}]
int64_t modPower(int64_t base, int64_t exp, int64_t mod) {
    int64_t result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp >>= 1;
    }
    return result;
}
\end{lstlisting}

\subsubsection{Modular Exponentiation Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(log exp) - logarithmic time
\item \textbf{Space Complexity}: O(1) constant space
\item \textbf{Modulo Arithmetic}: Handles large numbers with modulo
\item \textbf{Overflow Prevention}: Essential for competitive programming
\item \textbf{Applications}: Cryptography, number theory problems
\end{itemize}

\newpage
\subsection{GCD and LCM Functions}
Greatest Common Divisor and Least Common Multiple functions.

\begin{lstlisting}[caption={GCD and LCM Functions}]
int gcd(int a, int b) {
    while (b != 0) {
        a %= b;
        swap(a, b);
    }
    return a;
}

int lcm(int a, int b) {
    return (a / gcd(a, b)) * b;
}
\end{lstlisting}

\subsubsection{GCD/LCM Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(log min(a,b)) for GCD
\item \textbf{Space Complexity}: O(1) constant space
\item \textbf{Euclidean Algorithm}: Efficient GCD calculation
\item \textbf{LCM Formula}: LCM(a,b) = (a × b) / GCD(a,b)
\item \textbf{Applications}: Number theory, fraction simplification
\end{itemize}

\newpage
\subsection{Combinatorics}
Basic combinatorial functions with modular arithmetic support.

\begin{lstlisting}[caption={Standard nCr and nPr}]
// Don't use for n > 67 (int64_t overflow)
int64_t nCr(int n, int r) {
    if (r < 0 || r > n) return 0;
    if (r > n - r) r = n - r;
    int64_t res = 1;
    for (int i = 0; i < r; ++i) {
        res *= (n - i);
        res /= (i + 1);
    }
    return res;
}

// Don't use for n > 20 or large r (int64_t overflow)
int64_t nPr(int n, int r) {
    if (r < 0 || r > n) return 0;
    int64_t res = 1;
    for (int i = 0; i < r; ++i)
        res *= (n - i);
    return res;
}
\end{lstlisting}

\subsubsection{Standard Combinatorics Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(r) for both nCr and nPr
\item \textbf{Space Complexity}: O(1) constant space
\item \textbf{Limits}: n $\leq$ 67 for nCr, n $\leq$ 20 for nPr
\item \textbf{Optimization}: nCr uses symmetry C(n,r) = C(n,n-r)
\item \textbf{Applications}: Probability, counting problems
\end{itemize}

\newpage
\begin{lstlisting}[caption={Combinatorics with Modular Arithmetic}]
#include <vector>
using namespace std;

class Combinatorics {
private:
    static const int MOD = 1000000007;
    vector<int64_t> f, inv;
    
    int64_t pow(int64_t b, int64_t e) const {
        int64_t r = 1;
        while (e) {
            if (e & 1) r = r * b % MOD;
            b = b * b % MOD;
            e >>= 1;
        }
        return r;
    }

public:
    Combinatorics(int n) : f(n + 1), inv(n + 1) {
        f[0] = 1;
        for (int i = 1; i <= n; ++i)
            f[i] = f[i - 1] * i % MOD;
        inv[n] = pow(f[n], MOD - 2);
        for (int i = n - 1; i >= 0; --i)
            inv[i] = inv[i + 1] * (i + 1) % MOD;
    }
    int64_t nCr(int n, int r) const {
        if (r < 0 || r > n) return 0;
        return f[n] * inv[r] % MOD * inv[n - r] % MOD;
    }
    int64_t nPr(int n, int r) const {
        if (r < 0 || r > n) return 0;
        return f[n] * inv[n - r] % MOD;
    }
};
\end{lstlisting}

\subsubsection{Modular Combinatorics Notes}
\begin{itemize}
\item \textbf{Preprocessing}: O(n) time and space for setup
\item \textbf{Query Time}: O(1) per nCr/nPr call
\item \textbf{Limits}: n up to 10\textsuperscript{6} (uses ~16MB for n=10\textsuperscript{6})
\item \textbf{Features}: Handles large n, fast for many queries
\item \textbf{Fermat's Little Theorem}: Uses for modular inverse
\item \textbf{Applications}: Large combinatorial problems
\end{itemize}

\newpage
\subsection{Sieve of Eratosthenes}
Efficient algorithm to find all prime numbers up to a given limit.

\begin{lstlisting}[caption={Sieve of Eratosthenes}]
#include <bits/stdc++.h>
using namespace std;
// Time: O(n log log n), Space: O(n)
// Range: n up to 10^7 (typical CP limit)
// Memory: ~40MB for n=10^7
class Sieve {
public:
    vector<int> prime_factor, primes;
    
    Sieve(int n) {
        prime_factor.resize(n + 1);
        for (int i = 0; i <= n; i++) prime_factor[i] = i;
        for (int i = 2; i <= n; i++) {
            if (prime_factor[i] == i) {
                primes.push_back(i);
                for (int j = i * i; j <= n; j += i)
                    if (prime_factor[j] == j) prime_factor[j] = i;
            }
        }
    }
};

int main() {
    Sieve sieve(100);
    for (int p : sieve.primes) cout << p << " ";
    cout << "\n";
    for (int i = 12; i <= 15; i++) {
        cout << i << ": prime_factor=" << sieve.prime_factor[i] << "\n";
    }  
    return 0;
}
\end{lstlisting}

\subsubsection{Sieve Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(n log log n) - nearly linear
\item \textbf{Space Complexity}: O(n) for boolean array
\item \textbf{Prime Factors}: sieve.prime\_factor[x] gives smallest prime factor
\item \textbf{Prime List}: sieve.primes contains all primes up to n
\item \textbf{Memory Usage}: ~40MB for n=10\textsuperscript{7}
\item \textbf{Applications}: Prime factorization, number theory
\end{itemize}

\newpage
\section{Notes \& Utilities}

\subsection{Binary Conversions}
Convert numbers between different bases.

\begin{lstlisting}[caption={Binary to Decimal Conversion}]
// Convert binary string to decimal integer
string binaryStr = "1010";
int decimal = stoll(binaryStr, nullptr, 2);
// Result: 10

// Using bitset for larger binary strings
#include <bitset>
const int N = 32; // Enough for standard integers
int decimal = bitset<N>("1010").to_ulong();
// Result: 10

// For longer binary strings
const int LARGE_N = 10000; // For very large binary strings
unsigned long long largeDecimal = bitset<LARGE_N>(longBinaryStr).to_ullong();
\end{lstlisting}

\subsubsection{Binary to Decimal Notes}
\begin{itemize}
\item \textbf{stoll Method}: Limited to 64-bit integers
\item \textbf{bitset Method}: Can handle larger binary strings
\item \textbf{Time Complexity}: O(n) where n is binary string length
\item \textbf{Applications}: Binary arithmetic, bit manipulation
\end{itemize}

\newpage
\begin{lstlisting}[caption={Decimal to Binary Conversion}]
#include <bitset>

// Convert decimal to binary string
int decimal = 10;
const int N = 8; // Number of bits to represent
string binaryStr = bitset<N>(decimal).to_string();
// Result: "00001010"

// Remove leading zeros if needed
binaryStr = binaryStr.substr(binaryStr.find('1') != string::npos ? binaryStr.find('1') : N-1);
// Result: "1010"

// Using std::format (C++20)
#include <format>
string binaryStr = format("{:b}", decimal);
// Result: "1010"
\end{lstlisting}

\subsubsection{Decimal to Binary Notes}
\begin{itemize}
\item \textbf{bitset Method}: Most reliable for standard integers
\item \textbf{format Method}: Clean C++20 approach
\item \textbf{Leading Zeros}: Need manual handling for clean output
\item \textbf{Applications}: Binary representation, bit manipulation
\end{itemize}

\newpage
\begin{lstlisting}[caption={Coordinate Compression Template}]
template <typename T>
class Compress {
    vector<T> vals;
    unordered_map<T, int> idx;

public:
    Compress(const vector<T>& input) {
        vals = input;
        sort(vals.begin(), vals.end());
        vals.erase(unique(vals.begin(), vals.end()), vals.end());
        for (int i = 0; i < vals.size(); i++)
            idx[vals[i]] = i;
    }

    int operator[](const T& x) const { return idx.at(x); }
    T orig(int i) const { return vals.at(i); }
    int size() const { return vals.size(); }
};
\end{lstlisting}

\begin{lstlisting}[caption={Coordinate Compression Example}]
// Basic usage
vector<int> data = {1000000, 5, 10000, 6, 7, 1000};
Compress<int> comp(data);

// Convert original value to compressed index
for (int x : data) {
    cout << x << " -> " << comp[x] << endl;
}
// Output: 1000000->5, 5->0, 10000->3, 6->1, 7->2, 1000->4

// Get original value from compressed index
for (int i = 0; i < comp.size(); i++) {
    cout << i << " -> " << comp.orig(i) << endl;
}
// Output: 0->5, 1->6, 2->7, 3->1000, 4->10000, 5->1000000
\end{lstlisting}

\subsubsection{Coordinate Compression Notes}
\begin{itemize}
\item \textbf{Time Complexity}: O(N log N) for construction, O(1) for lookup
\item \textbf{Space Complexity}: O(N) for sorted list and hashmap
\item \textbf{Applications}: Segment trees, large value ranges, sparse data
\item \textbf{Features}: Preserves relative ordering, bidirectional mapping
\end{itemize}

\newpage
\begin{lstlisting}[caption={Measure Time Utility}]
#include <iostream>
#include <chrono>
#include <cstdint>
#include <iomanip>  
using namespace std;

template<typename Func, typename... Args>
double measure(Func&& f, Args&&... args) {
    auto start = chrono::high_resolution_clock::now();
    forward<Func>(f)(forward<Args>(args)...);
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<double, milli> elapsed = end - start;
    return elapsed.count();
}

int main() {
    cout << fixed << setprecision(4);

    double t1 = measure(funcVoid);
    cout << "funcVoid took " << t1 << " ms\n";

    int64_t res = 0;
    auto wrapper = [&](int n) { res = funcInt(n); };
    double t2 = measure(wrapper, 1000000);
    cout << "funcInt took " << t2 << " ms, sum = " << res << "\n";

    return 0;
}
\end{lstlisting}

\subsubsection{Measure Time Notes}
\begin{itemize}
\item \textbf{Template Function}: Works with any callable and arguments
\item \textbf{High Resolution}: Uses high\_resolution\_clock for precision
\item \textbf{Millisecond Precision}: Returns time in milliseconds
\item \textbf{Applications}: Performance analysis, algorithm comparison
\item \textbf{Wrapper Usage}: Use lambda wrapper for functions with return values
\end{itemize}

\newpage
\begin{lstlisting}[caption={Random Number Generator}]
#include <iostream>
#include <random>
#include <ctime>
using namespace std;

mt19937_64 ran(time(nullptr));

int r(int a, int b) {
    return ran() % (abs(b - a) + 1) + min(a, b);
}
\end{lstlisting}

\begin{lstlisting}[caption={Random Number Generator Example Usage}]
// Generate 5 random numbers between 1 and 100
for (int i = 0; i < 5; ++i) {
    cout << r(1, 100) << " ";
}
// Output: e.g. 42 17 89 3 76
\end{lstlisting}



\subsubsection{Number Generator Notes}
\begin{itemize}
\item \textbf{High Quality}: Uses mt19937\_64 for 64-bit random numbers
\item \textbf{Range Function}: r(a, b) returns random integer in [min(a,b), max(a,b)]
\item \textbf{Time Seeding}: Seeded with current time
\item \textbf{Applications}: Test case generation, competitive programming
\item \textbf{Note}: Not cryptographically secure
\end{itemize}

\newpage
\begin{lstlisting}[caption={String Split Utility}]
template<typename T>
vector<T> split(const string& line, char delimiter = ' ') {
    vector<T> result;
    stringstream ss(line);
    string token;

    while (getline(ss, token, delimiter)) {
        stringstream convert(token);
        T value;
        convert >> value;
        if (!convert.fail()) {
            result.push_back(value);
        }
    }

    return result;
}

// Basic string split to vector<string>
vector<string> split(const string& line, char delimiter = ' ') {
    vector<string> result;
    stringstream ss(line);
    string token;
    while (getline(ss, token, delimiter)) {
        result.push_back(token);
    }
    return result;
}
\end{lstlisting}

\begin{lstlisting}[caption={String Split Examples}]
// Split string into integers (default delimiter is space)
string line = "10 20 30";
vector<int> ints = split<int>(line);
// Result: [10, 20, 30]

// Split string into doubles (specify delimiter)
string line2 = "3.14,2.71,1.41";
vector<double> doubles = split<double>(line2, ',');
// Result: [3.14, 2.71, 1.41]

// Read a line from input and split it
string input;
getline(cin, input);
vector<int> values = split<int>(input);
// Now you can use the values vector as needed
\end{lstlisting}



\end{document}
